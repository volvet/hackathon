1.  定义
   typedef struct OpaqueVTCompressionSession* VTCompressionSessionRef;
   此为VTCompressionSession的定义, 从Apple的注释来理解, 这个是支持引用计数的CF OBJECT.  所谓CF OBJECT, 就是Apple Core Foundation Object.
   Core Foundation 是apple 的low-level C application programming interface. 也就是说,VTCompressionSession是Core Foundation 所提供的编程
   接口， 其实现是C Library, 不是Object C Library. 

2.  CALLBACK
   typedef void (*VTCompressionOutputCallback)(
                void * outputCallbackRefCon, 
                void * sourceFrameRefCon, 
                OSStatus  status, 
                VTEncodeInfoFlags   infoFlags, 
                CMSampleBuffRef     sampleBuffer);
  此为编码完成之后的回调函数。 需要注意的是这个函数的调用顺序是DECODE ORDER,  并非DISPLAY ORDER.  
  outputCallbackRefCon， 这个参数是Callback reference value,  其实是创建VTCompressionSession的时候所传入的用户定义的对象。 在每次
  Callback函数被调用的时候会作为参数传入。 
  sourceFrameRefCon,   这个参数是frame reference value,  其实是在调用每个Frame encode 的时候所传入的用户定义跟Frame有关的对象。 
  这个对象会在Frame encode 完成的时候，  触发回调的时候作为参数传入，  Frame的属性， 比如Time Stamp之类可以定义在这个对象中。  
  status,  noErr 表示编码没有错误,  否则会有错误码返回。  
  infoFlags,   有两种可能的值， Asynchronous 表示编码是异步调用，  FrameDropped, 表示这个Frame被Drop了。 
  CMSampleBuffRef  这个就是返回的视频码流。  
    从这个CALLBACK的描述可以大致推测,  VTCompressionSession 很可能可以支持 Baseline, Main, 甚至 High Profile的编码(指AVC)


3  EncoderID
   VT_EXPORT const CFStringRef kVTVideoEncoderSpecification_EncoderID(_OSX_AVAILABLE_STARTING)(_MAC_10_0, IPHONE_8_0); 
    这个是简单的EncodeID定义，  从这里可以看出， 其实APPLE在iOS8.0和MAC 10.0 上都提供了硬件编码支持.  

4  VTCompressionSessionCreate
   VT_EXPORT  OSStatus  VTCompressionSesionCreate(
               CFAllocatorRef    allocator, 
               int32_t           width, 
               int32_t           height, 
               CMVideoCodecType  codecType, 
               CFDirectionRef    encodeSpecifacation, 
               CFDirectionRef    sourceImageBufferAttribututes, 
               CFAllocatorRef    compressedDataAllocator,  
               VTCompressionOutputCallback    outputCallback,
               void*             outputCallbackRefCon, 
               VTCompressionSessionRef  *   compressionSessionOut)
   这个是创建 VTCompressionSession的函数,  其输入参数大多简单,  需要提一下的是两个字典,  encodeSpecification 和 
   sourceImageBufferAttributes,  这个没有官方文档说明,  需要进一步搜索SDK中的头文件定义.  容我卖个关子,  关于这
   两个个参数以后再说. 
  
5  PixelBufferPool
   VT_EXPORT CVPixelBufferPoolRef  VTCompressionSessionGetPixelBufferPool(VTCompressionSessionRef session)
   当VTCompressionSession被创建时候,  需要输入PIXEL FORMAT.   然后从VTCompressionSessionRef中取得的PixelBufferPool就是
   基于输入的PIXEL FORMAT来创建的.  如果Source PIXEL format 和 Compress Pixel Format 不一致,  Video Toolbox 会自动进行
   Color Space Convert(这个也许需要做实验验证下)


6.  CompressionSessionPrepareToEncodeFrames
    VT_EXPORT OSStatus  VTCompressionSessionPrepareToEncodeFrames(VTCompressionSessionRef session)
   真正编码前的准备.   官方的注释上解释这个调用是为了让硬件编码器有机会申请其所需资源. 


7.  EncodeFrame 
    VT_EXPORT OSStatus  VTCompressionSesionEncodeFrame(
            VTCompressionSessionRef session,
            CVImageBufferRef    imageBuffer,
            CMTime              presentationTimeStamp,
            CMTime              duration, 
            CFDirectionaryRef   frameProperties, 
            void *              sourceFrameRefCon, 
            VTEncodeInfoFlags   * infoFlagsOut)
   终于看到真正的编码函数了, 激动ing.    前两个参数非常容易理解, 当然是session本身和需要编码的raw data. 第三个参数
   应该是指Frame Time Stamp.   但是从CALLBACK中并没有看到presentationTimeStamp返回. 据此推测,  Frame Time Stamp斯需
   要调用者想办法维护了.  如前所说, 使用sourceFrameRefCon也许是个办法.    第四个参数 duration, 对于RealTime 应用意义
   不大.  本来Capture Frame Rate 就可能变化剧烈.    第五个参数 frameProperties也许是最有意思的参数了,  目前这个字典
   可以支持什么样的参数输入, 还无法在官方文档和VTCompressionSession.h中找到.  我们需要搜索SDK中的其他头文件定义来探索
   奥密.   容我再卖个关子,  以后再说此参数.  第六个参数是作为Out的变量,  这个定义已经在前文描述过了.  

      
8.  VTCompressionSessionInvalidater
    VT_EXPORT  OSStatus  VTCompressionSessionInvalidate(VTCompressionSesionRef session)
    这个函数非常简单, 就相当于CompressionSession的TearDown,  把session设置invalidate之后, 可以用CFRelease来释放session. 
    
9.  GetTypeID
    VT_EXPORT  CFTypeID   VTCompressionSessionGetTypeID(void)
    这个函数也很简单,  得到Type ID而已.  
    
    
10. VTCompressionSessionCompleteFrames
    VT_EXPORT OSStatus  VTCompressionSessionCompleteFrames(
                VTCompressionSessionRef session, 
                CMTime  completeUntilPresentationTimeStamp) 
    这个函数比较简单,  就是Flush操作.   因为编码工作在异步状态, 所以输入RAW data 之后, 只能等待CALLBACK得到压缩码流. 
    这个函数就提供了一个强制Flush操作, 而且还可以输入TimeStamp来要求Flush 这个TimeStamp之前的Frame.  
                                                      
11.  Multi-pass encoding.   
    APPLE 的HW ENCODE 还支持Multi-pass,  大致浏览了Mulit-pass 相关的API之后, 感觉有些象X264所提供的Mulit-pass, 应该并
    不适合RealTime应用, 在此略过不表.  有兴趣可以去了解X264的Multi-Pass相关模块.  
    
    
关于VTCompressionSession的API介绍已经基本结束,  但是疑问却并未消散,  到底APPLE的HW CODEC能否适合产品使用,  我想这些奥秘
都在我们尚未找到答案的几个字典之中.   未完待续.  


致谢:   本文的写作得到了Sand同学的大力协助,  借此致以谢意.  
   

